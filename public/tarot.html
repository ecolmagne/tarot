<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot en ligne</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .container {
            width: 100%;
            max-width: 1400px;
        }

        /* √âcran d'accueil */
        .welcome-screen {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .welcome-screen h1 {
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .welcome-screen input {
            padding: 15px;
            font-size: 1.1em;
            border: 2px solid #ddd;
            border-radius: 10px;
            width: 100%;
            max-width: 300px;
            margin-bottom: 20px;
        }

        .welcome-screen button {
            padding: 15px 40px;
            font-size: 1.1em;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        .welcome-screen button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .player-count-selector {
            margin: 20px 0;
        }

        .player-count-selector button {
            padding: 10px 20px;
            margin: 5px;
            background: #f0f0f0;
            color: #333;
        }

        .player-count-selector button.selected {
            background: #667eea;
            color: white;
        }

        /* Salle d'attente */
        .lobby-screen {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: none;
        }

        .lobby-screen h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .room-code {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .share-link {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            word-break: break-all;
        }

        .players-list {
            margin: 20px 0;
            text-align: left;
        }

        .player-item {
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Table de jeu */
        .game-screen {
            display: none;
            color: white;
        }

        .game-header {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        .game-table {
            background: radial-gradient(ellipse at center, #2d5016 0%, #1a3009 100%);
            border-radius: 20px;
            padding: 30px;
            min-height: 400px;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .players-area {
            position: relative;
            width: 100%;
            min-height: 300px;
            margin-bottom: 30px;
        }

        .opponent-player {
            position: absolute;
            background: rgba(52, 152, 219, 0.3);
            border: 3px solid #3498db;
            border-radius: 15px;
            padding: 15px 20px;
            text-align: center;
            min-width: 120px;
            transition: all 0.3s;
        }

        .opponent-player.current-player {
            background: rgba(46, 204, 113, 0.4);
            border-color: #27ae60;
        }

        .opponent-player.current-turn {
            box-shadow: 0 0 20px rgba(255,215,0,0.8);
            border: 3px solid gold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1.1em;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .player-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            margin-top: 5px;
        }

        .center-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
        }

        .center-area > * {
            pointer-events: auto;
        }

        .played-card {
            width: 80px;
            height: 120px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            position: relative;
            transition: all 0.3s;
        }

        .played-card:hover {
            transform: translateY(-10px);
        }

        .card-suit {
            font-size: 2em;
        }

        .card-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .player-hand {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .hand-title {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .cards-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .card {
            width: 70px;
            height: 105px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s;
            flex-shrink: 0;
            border: 2px solid #d4af37;
            padding: 4px;
            position: relative;
            font-family: 'Times New Roman', serif;
        }

        .card:hover {
            transform: translateY(-15px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card.disabled:hover {
            transform: none;
        }

        .card.hearts, .card.diamonds {
            color: #dc143c;
        }

        .card.clubs, .card.spades {
            color: #000;
        }

        .card.trump {
            background: linear-gradient(135deg, #fff9e6 0%, #ffe6cc 100%);
            color: #8b4513;
            border-color: #d4af37;
        }

        .card-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .card-suit {
            font-size: 1.5em;
        }

        .card-corner {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
        }

        .card-corner.top-left {
            top: 2px;
            left: 4px;
        }

        .card-corner.bottom-right {
            bottom: 2px;
            right: 4px;
            transform: rotate(180deg);
        }

        .card-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .card-figure {
            font-size: 0.65em;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .trump-number {
            font-size: 2em;
            font-weight: bold;
            color: #8b4513;
        }

        .trump-label {
            font-size: 0.6em;
            text-transform: uppercase;
            color: #8b4513;
            margin-top: -5px;
        }

        .excuse-star {
            font-size: 2.5em;
            color: #ff6b6b;
        }

        .excuse-label {
            font-size: 0.55em;
            text-transform: uppercase;
            color: #333;
            margin-top: -8px;
        }

        .trick-winner {
            background: rgba(255,215,0,0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.2em;
        }

        /* Score */
        .scores-screen {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: none;
        }

        .scores-screen h2 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }

        .scores-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .scores-table th,
        .scores-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .scores-table th {
            background: #667eea;
            color: white;
        }

        .winner-row {
            background: #fff9c4;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .welcome-screen,
            .lobby-screen,
            .scores-screen {
                padding: 20px;
            }

            .welcome-screen h1 {
                font-size: 1.8em;
            }

            .game-header {
                padding: 10px;
            }

            .game-info {
                gap: 15px;
            }

            .info-value {
                font-size: 1.1em;
            }

            .game-table {
                padding: 15px;
            }

            .players-area {
                min-height: 250px;
            }

            .opponent-player {
                min-width: 90px;
                padding: 10px 15px;
                font-size: 0.9em;
            }

            .center-area {
                min-height: 150px;
                margin: 15px 0;
            }

            .played-card {
                width: 60px;
                height: 90px;
                font-size: 1.2em;
            }

            .card {
                width: 60px;
                height: 90px;
            }

            .cards-container {
                gap: 5px;
            }
        }

        @media (max-width: 480px) {
            .welcome-screen h1 {
                font-size: 1.5em;
            }

            .opponent-player {
                min-width: 70px;
                padding: 8px 10px;
                font-size: 0.8em;
            }

            .player-name {
                font-size: 0.9em;
            }

            .card {
                width: 50px;
                height: 75px;
                font-size: 0.8em;
            }

            .played-card {
                width: 50px;
                height: 75px;
            }
        }

        .card.selected {
            border: 3px solid #f39c12;
            transform: translateY(-10px);
            box-shadow: 0 8px 20px rgba(243, 156, 18, 0.5);
        }

        .bidding-screen,
        .dog-screen,
        .king-call-screen {
            color: #333;
        }

        .message-banner {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
        }

        .message-banner.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="message-banner" id="messageBanner"></div>
    
    <div class="container">
        <!-- √âcran d'accueil -->
        <div class="welcome-screen" id="welcomeScreen">
            <h1>üÉè Tarot en ligne</h1>
            <div>
                <input type="text" id="playerName" placeholder="Votre nom" maxlength="20">
            </div>
            
            <div class="player-count-selector">
                <p style="margin-bottom: 10px;">Nombre de joueurs:</p>
                <button onclick="selectPlayerCount(3)" class="player-count-btn" data-count="3">3 joueurs</button>
                <button onclick="selectPlayerCount(4)" class="player-count-btn selected" data-count="4">4 joueurs</button>
                <button onclick="selectPlayerCount(5)" class="player-count-btn" data-count="5">5 joueurs</button>
            </div>
            
            <div id="roomButtons">
                <button onclick="createRoom()">Cr√©er une partie</button>
                <button onclick="showJoinRoom()">Rejoindre une partie</button>
            </div>
            
            <div id="joinRoomDiv" class="hidden" style="margin-top: 20px;">
                <input type="text" id="roomCode" placeholder="Code de la partie" maxlength="6">
                <button onclick="joinRoom()">Rejoindre</button>
            </div>
        </div>

        <!-- Salle d'attente -->
        <div class="lobby-screen" id="lobbyScreen">
            <h2>Salle d'attente</h2>
            <div class="room-code">
                Code: <span id="displayRoomCode"></span>
            </div>
            <div class="share-link">
                <strong>Lien √† partager:</strong><br>
                <span id="shareLink"></span>
            </div>
            <button onclick="copyShareLink()" style="margin: 10px 0;">üìã Copier le lien</button>
            
            <div class="players-list" id="playersList"></div>
            
            <div id="startGameBtn" class="hidden">
                <button onclick="startGame()">Commencer la partie</button>
            </div>
            
            <button onclick="leaveRoom()" style="background: #e74c3c;">Quitter</button>
        </div>

        <!-- Interface d'ench√®res -->
        <div class="bidding-screen" id="biddingScreen" style="display: none;">
            <div style="background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 1400px; margin: 0 auto;">
                <h2 style="color: #667eea; margin-bottom: 30px; text-align: center;">Phase d'ench√®res</h2>
                
                <div id="biddingInfo" style="background: #f5f5f5; padding: 20px; border-radius: 10px; margin-bottom: 30px; text-align: center;">
                    <p id="biddingTurnInfo" style="font-size: 1.2em; font-weight: bold; color: #333;"></p>
                    <div id="currentBids" style="margin-top: 15px; font-size: 0.9em; color: #666;"></div>
                </div>

                <div id="biddingButtons" style="display: none; text-align: center; margin-bottom: 30px;">
                    <p style="margin-bottom: 20px; font-weight: bold; color: #333;">Votre ench√®re :</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; max-width: 600px; margin: 0 auto; justify-content: center;">
                        <button onclick="makeBid('pass')" style="padding: 15px 30px; font-size: 1em; background: #95a5a6; color: white; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s; flex: 1; min-width: 120px;">
                            Passer
                        </button>
                        <button onclick="makeBid('petite')" id="bidPetite" style="padding: 15px 30px; font-size: 1em; background: #3498db; color: white; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s; flex: 1; min-width: 120px;">
                            Petite
                        </button>
                        <button onclick="makeBid('garde')" id="bidGarde" style="padding: 15px 30px; font-size: 1em; background: #f39c12; color: white; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s; flex: 1; min-width: 120px;">
                            Garde
                        </button>
                        <button onclick="makeBid('garde-sans')" id="bidGardeSans" style="padding: 15px 30px; font-size: 1em; background: #e74c3c; color: white; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s; flex: 1; min-width: 120px;">
                            Garde sans
                        </button>
                        <button onclick="makeBid('garde-contre')" id="bidGardeContre" style="padding: 15px 30px; font-size: 1em; background: #8e44ad; color: white; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s; flex: 1; min-width: 120px;">
                            Garde contre
                        </button>
                    </div>
                </div>

                <!-- Main du joueur visible pendant les ench√®res -->
                <div class="player-hand" style="background: rgba(0,0,0,0.05);">
                    <div class="hand-title">Votre main (<span id="biddingHandCount">0</span> cartes)</div>
                    <div class="cards-container" id="biddingPlayerHand"></div>
                </div>
            </div>
        </div>

        <!-- √âcran de l'√©cart (chien) -->
        <div class="dog-screen" id="dogScreen" style="display: none;">
            <div style="background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                <h2 style="color: #667eea; margin-bottom: 20px; text-align: center;">Faites votre √©cart</h2>
                <div id="calledKingDogInfo" style="display: none; text-align: center; margin-bottom: 15px; background: rgba(102,126,234,0.1); padding: 10px; border-radius: 10px;">
                    <span style="font-weight: bold; color: #667eea;">Roi appel√© :</span> <span id="calledKingDog" style="font-size: 1.1em;">-</span>
                </div>
                <p style="text-align: center; margin-bottom: 20px; color: #666;">S√©lectionnez <span id="dogCardsNeeded">?</span> cartes √† √©carter (pas d'atouts sauf avec excuse, pas de rois)</p>
                
                <div id="dogInfo" style="background: #f5f5f5; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                    <p><strong>Le chien :</strong></p>
                    <div id="dogCards" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;"></div>
                </div>

                <div style="background: #e8f5e9; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                    <p><strong>Cartes s√©lectionn√©es pour l'√©cart : <span id="selectedCount">0</span> / <span id="selectedNeeded">6</span></strong></p>
                    <div id="selectedCards" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;"></div>
                </div>

                <div class="player-hand">
                    <div class="hand-title">Votre main (<span id="dogHandCount">0</span> cartes)</div>
                    <div class="cards-container" id="dogPlayerHand"></div>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="validateDog()" id="validateDogBtn" style="padding: 15px 40px; font-size: 1.1em; background: #27ae60; color: white; border: none; border-radius: 10px; cursor: pointer; opacity: 0.5;" disabled>
                        Valider l'√©cart
                    </button>
                </div>
            </div>
        </div>

        <!-- √âcran d'attente pendant l'√©cart (pour les d√©fenseurs) -->
        <div id="waitingDogScreen" style="display: none;">
            <div style="background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 1400px; margin: 0 auto; color: #333;">
                <h2 style="color: #667eea; margin-bottom: 20px; text-align: center;">Le preneur fait son √©cart</h2>
                <div id="calledKingWaitingInfo" style="display: none; text-align: center; margin-bottom: 15px; background: rgba(102,126,234,0.1); padding: 10px; border-radius: 10px;">
                    <span style="font-weight: bold; color: #667eea;">Roi appel√© :</span> <span id="calledKingWaiting" style="font-size: 1.1em;">-</span>
                </div>
                <p style="text-align: center; margin-bottom: 20px; color: #666; font-size: 1.1em;">‚è≥ En attente...</p>

                <div style="background: #f5f5f5; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                    <p><strong>Le chien :</strong></p>
                    <div id="waitingDogCards" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;"></div>
                </div>

                <div class="player-hand" style="background: rgba(0,0,0,0.05);">
                    <div class="hand-title">Votre main (<span id="waitingDogHandCount">0</span> cartes)</div>
                    <div class="cards-container" id="waitingDogPlayerHand"></div>
                </div>
            </div>
        </div>

        <!-- √âcran d'appel de Roi (5 joueurs) -->
        <div class="king-call-screen" id="kingCallScreen" style="display: none;">
            <div style="background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 1400px; margin: 0 auto;">
                <h2 style="color: #667eea; margin-bottom: 30px; text-align: center;">Appel d'un Roi</h2>
                
                <div id="kingCallMessage" style="text-align: center; margin-bottom: 30px; font-size: 1.1em; color: #666;">
                    <p>Le preneur doit appeler un Roi pour jouer avec lui...</p>
                </div>
                
                <div id="kingCallButtons" style="display: none;">
                    <p style="text-align: center; margin-bottom: 20px; font-weight: bold; color: #333;">Choisissez le Roi que vous appelez :</p>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; max-width: 800px; margin: 0 auto; justify-content: center;">
                        <button onclick="callKing('‚ô†')" style="padding: 15px 30px; font-size: 1em; background: #2c3e50; color: white; border: none; border-radius: 10px; cursor: pointer; flex: 1; min-width: 150px;">
                            Roi de ‚ô† Pique
                        </button>
                        <button onclick="callKing('‚ô•')" style="padding: 15px 30px; font-size: 1em; background: #e74c3c; color: white; border: none; border-radius: 10px; cursor: pointer; flex: 1; min-width: 150px;">
                            Roi de ‚ô• C≈ìur
                        </button>
                        <button onclick="callKing('‚ô£')" style="padding: 15px 30px; font-size: 1em; background: #2c3e50; color: white; border: none; border-radius: 10px; cursor: pointer; flex: 1; min-width: 150px;">
                            Roi de ‚ô£ Tr√®fle
                        </button>
                        <button onclick="callKing('‚ô¶')" style="padding: 15px 30px; font-size: 1em; background: #e74c3c; color: white; border: none; border-radius: 10px; cursor: pointer; flex: 1; min-width: 150px;">
                            Roi de ‚ô¶ Carreau
                        </button>
                    </div>
                </div>

                <!-- Main du preneur visible pendant l'appel -->
                <div class="player-hand" style="background: rgba(0,0,0,0.05); margin-top: 30px;">
                    <div class="hand-title">Votre main (<span id="kingCallHandCount">0</span> cartes)</div>
                    <div class="cards-container" id="kingCallPlayerHand"></div>
                </div>
            </div>
        </div>

        <!-- Table de jeu -->
        <div class="game-screen" id="gameScreen">
            <div class="game-header">
                <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; flex-wrap: wrap;">
                    <div class="game-info">
                        <div class="info-item">
                            <span class="info-label">Contrat</span>
                            <span class="info-value" id="contract">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Preneur</span>
                            <span class="info-value" id="taker">-</span>
                        </div>
                        <div class="info-item" id="calledKingInfo" style="display: none;">
                            <span class="info-label">Roi appel√©</span>
                            <span class="info-value" id="calledKingValue">-</span>
                        </div>
                    </div>
                    
                    <!-- Affichage du chien dans le header -->
                    <div id="dogDisplay" class="hidden" style="background: rgba(255,215,0,0.15); padding: 8px; border-radius: 8px; text-align: center;">
                        <p style="font-size: 0.8em; margin-bottom: 3px; color: white; font-weight: bold;">üé¥ Le Chien</p>
                        <div style="display: flex; gap: 3px; justify-content: center;" id="dogCardsDisplay"></div>
                    </div>
                    
                    <!-- Affichage du dernier pli -->
                    <div id="lastTrickDisplay" class="hidden" style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                        <p style="font-size: 0.8em; margin-bottom: 3px; text-align: center; color: white;">Dernier pli :</p>
                        <div style="display: flex; gap: 3px; justify-content: center;" id="lastTrickCards"></div>
                    </div>
                    
                    <button onclick="leaveGame()" style="background: #e74c3c; padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; color: white; font-size: 1em;">Quitter</button>
                    <button id="debugSkipBtn" onclick="skipToLastTrick()" style="display: none; background: #f39c12; padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; color: white; font-size: 1em;">‚è© Dernier pli</button>
                </div>
            </div>

            <div class="game-table">
                <div class="players-area" id="playersArea"></div>
                
                <div class="center-area" id="centerArea"></div>
                
                <div id="trickWinner" class="trick-winner hidden"></div>

                <!-- Affichage du chien (visible par tous) -->
                <div class="player-hand">
                    <div class="hand-title">Votre main (<span id="handCount">0</span> cartes)</div>
                    <div class="cards-container" id="playerHand"></div>
                </div>
            </div>
        </div>

        <!-- √âcran des scores -->
        <div class="scores-screen" id="scoresScreen">
            <h2>üèÜ Scores de la partie</h2>
            <table class="scores-table">
                <thead>
                    <tr>
                        <th>Joueur</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody id="scoresBody"></tbody>
            </table>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                <button onclick="startNewGame()" style="padding: 15px 30px; font-size: 1.1em; background: #27ae60; color: white; border: none; border-radius: 10px; cursor: pointer;">
                    üîÑ Nouvelle partie
                </button>
                <button onclick="backToWelcome()" style="padding: 15px 30px; font-size: 1.1em; background: #e74c3c; color: white; border: none; border-radius: 10px; cursor: pointer;">
                    üè† Quitter
                </button>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Connexion Socket.io
        const socket = io();

        // √âtat de l'application
        const state = {
            playerName: '',
            roomCode: '',
            playerId: null,
            playerCount: 4,
            isHost: false,
            players: [],
            gameState: null,
            myHand: [],
            playedCards: [],
            currentTrick: 0,
            selectedDogCards: [],
            dogCards: [],
            currentBids: [],
            lastTrickCards: null
        };

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substring(2, 15);
        }

        function selectPlayerCount(count) {
            state.playerCount = count;
            document.querySelectorAll('.player-count-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.dataset.count) === count) {
                    btn.classList.add('selected');
                }
            });
        }

        function showMessage(message, duration = 3000) {
            const banner = document.getElementById('messageBanner');
            banner.textContent = message;
            banner.classList.add('show');
            setTimeout(() => {
                banner.classList.remove('show');
            }, duration);
        }

        function createRoom() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                showMessage('‚ùå Veuillez entrer votre nom');
                return;
            }

            state.playerName = name;
            state.isHost = true;

            // √âmettre l'√©v√©nement de cr√©ation de partie
            socket.emit('createRoom', {
                playerName: name,
                playerCount: state.playerCount
            });
        }

        function showJoinRoom() {
            document.getElementById('joinRoomDiv').classList.remove('hidden');
        }

        function joinRoom() {
            const name = document.getElementById('playerName').value.trim();
            const code = document.getElementById('roomCode').value.trim().toUpperCase();

            if (!name) {
                showMessage('‚ùå Veuillez entrer votre nom');
                return;
            }

            if (!code) {
                showMessage('‚ùå Veuillez entrer le code de la partie');
                return;
            }

            state.playerName = name;

            // √âmettre l'√©v√©nement de rejoindre une partie
            socket.emit('joinRoom', {
                playerName: name,
                roomCode: code
            });
        }

        function showLobby() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            document.getElementById('displayRoomCode').textContent = state.roomCode;
            
            const shareLink = window.location.origin + window.location.pathname + '?room=' + state.roomCode;
            document.getElementById('shareLink').textContent = shareLink;

            updatePlayersList();

            if (state.isHost) {
                checkStartGameButton();
            }
        }

        function updatePlayersList() {
            const listDiv = document.getElementById('playersList');
            listDiv.innerHTML = '<h3>Joueurs (' + state.players.length + '/' + state.playerCount + ')</h3>';

            state.players.forEach(player => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <div class="player-avatar">${player.name.charAt(0).toUpperCase()}</div>
                    <div>${player.name}${player.isHost ? ' üëë' : ''}</div>
                `;
                listDiv.appendChild(item);
            });
        }

        function checkStartGameButton() {
            const btnDiv = document.getElementById('startGameBtn');
            
            if (state.players.length === state.playerCount) {
                btnDiv.classList.remove('hidden');
            } else {
                btnDiv.classList.add('hidden');
            }
        }

        function copyShareLink() {
            const link = document.getElementById('shareLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                showMessage('‚úÖ Lien copi√© !');
            });
        }

        function leaveRoom() {
            socket.emit('leaveRoom', { roomCode: state.roomCode });
            backToWelcome();
        }

        function startGame() {
            socket.emit('startGame', { roomCode: state.roomCode });
        }

        function showWaitingDogScreen() {
            document.getElementById('biddingScreen').style.display = 'none';
            document.getElementById('kingCallScreen').style.display = 'none';
            document.getElementById('waitingDogScreen').style.display = 'block';

            // Afficher le roi appel√© si √† 5 joueurs
            const calledKingWaiting = document.getElementById('calledKingWaiting');
            if (calledKingWaiting && state.gameState && state.gameState.calledKing) {
                calledKingWaiting.textContent = state.gameState.calledKing;
                document.getElementById('calledKingWaitingInfo').style.display = 'block';
            }

            // Afficher les cartes du chien
            const container = document.getElementById('waitingDogCards');
            container.innerHTML = '';
            if (state.dogCards) {
                state.dogCards.forEach(card => {
                    const cardDiv = createCardElement(card, false);
                    cardDiv.style.width = '60px';
                    cardDiv.style.height = '90px';
                    cardDiv.onclick = null;
                    cardDiv.style.cursor = 'default';
                    container.appendChild(cardDiv);
                });
            }

            // Afficher la main du joueur (lecture seule)
            const handContainer = document.getElementById('waitingDogPlayerHand');
            handContainer.innerHTML = '';
            document.getElementById('waitingDogHandCount').textContent = state.myHand.length;
            state.myHand.forEach(card => {
                const cardDiv = createCardElement(card, true);
                cardDiv.onclick = null;
                cardDiv.style.cursor = 'default';
                handContainer.appendChild(cardDiv);
            });
        }

        function showGameScreen() {
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('biddingScreen').style.display = 'none';
            document.getElementById('dogScreen').style.display = 'none';
            document.getElementById('waitingDogScreen').style.display = 'none';
            document.getElementById('kingCallScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';

            // Nettoyer les r√©sidus de la partie pr√©c√©dente
            document.getElementById('centerArea').innerHTML = '';
            document.getElementById('lastTrickDisplay').classList.add('hidden');
            document.getElementById('debugSkipBtn').style.display = 'none';

            updateGameHeader();
            renderOpponents();
            renderPlayerHand();
        }

        function updateGameHeader() {
            if (!state.gameState) return;
            
            document.getElementById('contract').textContent = state.gameState.contract || '-';
            document.getElementById('taker').textContent = state.gameState.taker || '-';
        }

        function renderOpponents() {
            const area = document.getElementById('playersArea');
            area.innerHTML = '';

            const playerCount = state.players.length;
            const myIndex = state.players.findIndex(p => p.id === state.playerId);
            
            // Calculer les positions en cercle/polygone
            const positions = calculatePlayerPositions(playerCount, myIndex);
            
            state.players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = 'opponent-player';
                
                // Le joueur connect√© a un style diff√©rent
                if (player.id === state.playerId) {
                    div.classList.add('current-player');
                }
                
                // Highlight du joueur dont c'est le tour
                if (state.gameState && index === state.gameState.currentPlayerIndex) {
                    div.classList.add('current-turn');
                }
                
                // Position calcul√©e
                const pos = positions[index];
                div.style.left = pos.x + '%';
                div.style.top = pos.y + '%';
                div.style.transform = 'translate(-50%, -50%)';
                
                let badge = '';
                if (player.id === state.playerId) {
                    badge = '<div class="player-badge">üë§ Vous</div>';
                }
                
                // Trouver la carte jou√©e par ce joueur dans le pli actuel
                let playedCardHTML = '';
                if (state.playedCards && state.playedCards.length > 0) {
                    const playerCard = state.playedCards.find(pc => pc.playerIndex === index);
                    if (playerCard) {
                        const cardDiv = createCardElement(playerCard.card, false);
                        cardDiv.style.width = '35px';
                        cardDiv.style.height = '52px';
                        cardDiv.style.fontSize = '0.5em';
                        cardDiv.style.display = 'inline-block';
                        cardDiv.style.marginTop = '5px';
                        playedCardHTML = '<div style="margin-top: 5px;">' + cardDiv.outerHTML + '</div>';
                    }
                }
                
                div.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    ${badge}
                    ${playedCardHTML}
                `;
                area.appendChild(div);
            });
        }

        function calculatePlayerPositions(playerCount, myIndex) {
            const positions = [];
            
            // R√©organiser pour que le joueur soit toujours en bas
            const orderedIndices = [];
            for (let i = 0; i < playerCount; i++) {
                orderedIndices.push((myIndex + i) % playerCount);
            }
            
            if (playerCount === 3) {
                // Triangle : moi en bas, 2 en haut
                const layout = {
                    0: { x: 50, y: 85 },  // Moi en bas
                    1: { x: 20, y: 20 },  // Gauche en haut
                    2: { x: 80, y: 20 }   // Droite en haut
                };
                orderedIndices.forEach((originalIndex, layoutIndex) => {
                    positions[originalIndex] = layout[layoutIndex];
                });
            } else if (playerCount === 4) {
                // Carr√© : moi en bas, 1 √† gauche, 1 en haut, 1 √† droite
                const layout = {
                    0: { x: 50, y: 85 },  // Moi en bas
                    1: { x: 10, y: 50 },  // Gauche
                    2: { x: 50, y: 15 },  // Haut
                    3: { x: 90, y: 50 }   // Droite
                };
                orderedIndices.forEach((originalIndex, layoutIndex) => {
                    positions[originalIndex] = layout[layoutIndex];
                });
            } else if (playerCount === 5) {
                // Pentagone : moi en bas, 2 en haut-c√¥t√©s, 2 au milieu-c√¥t√©s
                const layout = {
                    0: { x: 50, y: 85 },  // Moi en bas
                    1: { x: 15, y: 60 },  // Gauche-bas
                    2: { x: 20, y: 25 },  // Gauche-haut
                    3: { x: 80, y: 25 },  // Droite-haut
                    4: { x: 85, y: 60 }   // Droite-bas
                };
                orderedIndices.forEach((originalIndex, layoutIndex) => {
                    positions[originalIndex] = layout[layoutIndex];
                });
            }
            
            return positions;
        }

        function renderPlayerHand() {
            const container = document.getElementById('playerHand');
            container.innerHTML = '';
            document.getElementById('handCount').textContent = state.myHand.length;

            state.myHand.forEach((card, index) => {
                const cardDiv = createCardElement(card, true);

                if (!canPlayCard(card)) {
                    cardDiv.classList.add('disabled');
                } else {
                    cardDiv.onclick = () => playCard(index);
                }

                container.appendChild(cardDiv);
            });
        }

        function canPlayCard(card) {
            if (!state.gameState || !state.gameState.trickCards) return true;
            
            // R√®gle sp√©ciale : au premier pli, la couleur du Roi appel√© est prot√©g√©e
            if (state.gameState.calledKingSuit && state.currentTrick === 1) {
                const isFirstPlayer = state.gameState.trickCards.length === 0;
                const isCalledKing = card.value === 'R' && card.suit === state.gameState.calledKingSuit;

                // D√©terminer la couleur d'entame depuis les cartes jou√©es
                let leadSuitForKing = null;
                if (state.gameState.trickCards.length > 0) {
                    const firstCard = state.gameState.trickCards[0].card;
                    if (firstCard.isTrump) leadSuitForKing = 'trump';
                    else if (!firstCard.isExcuse) leadSuitForKing = firstCard.suit;
                }
                const leadIsCalledSuit = leadSuitForKing === state.gameState.calledKingSuit;

                if (card.suit === state.gameState.calledKingSuit && !card.isTrump && !card.isExcuse) {
                    if (isCalledKing && !isFirstPlayer) {
                        const hasOtherCards = state.myHand.some(c =>
                            !(c.value === 'R' && c.suit === state.gameState.calledKingSuit)
                        );
                        if (hasOtherCards) return false;
                    } else if (!isCalledKing && !leadIsCalledSuit) {
                        const hasOtherCards = state.myHand.some(c =>
                            c.suit !== state.gameState.calledKingSuit ||
                            c.isTrump ||
                            c.isExcuse
                        );
                        if (hasOtherCards) return false;
                    }
                }
            }
            // √Ä partir du 2√®me pli, on peut jouer normalement la couleur du Roi appel√©
            
            // Si c'est le premier joueur du pli
            if (state.gameState.trickCards.length === 0) {
                return true;
            }

            const leadSuit = state.gameState.leadSuit;

            // L'excuse peut toujours √™tre jou√©e
            if (card.isExcuse) {
                return true;
            }

            // Si l'Excuse a √©t√© jou√©e en ouverture, le joueur suivant choisit librement
            if (leadSuit === null) {
                return true;
            }

            // Si on demande un atout
            if (leadSuit === 'trump') {
                if (card.isTrump) {
                    // Obligation de monter : trouver le plus haut atout d√©j√† jou√©
                    let highestTrump = 0;
                    state.gameState.trickCards.forEach(tc => {
                        if (tc.card.isTrump && !tc.card.isExcuse) {
                            const trumpValue = parseInt(tc.card.value);
                            if (trumpValue > highestTrump) {
                                highestTrump = trumpValue;
                            }
                        }
                    });
                    
                    const myTrumpValue = parseInt(card.value);
                    
                    // Je dois monter si j'ai un atout plus haut
                    if (myTrumpValue > highestTrump) {
                        return true; // Je peux jouer cet atout plus haut
                    } else {
                        // Je ne peux jouer cet atout que si je n'ai pas d'atout plus haut
                        const hasHigherTrump = state.myHand.some(c => 
                            c.isTrump && !c.isExcuse && parseInt(c.value) > highestTrump
                        );
                        return !hasHigherTrump;
                    }
                }
                
                // Pas d'atout en main
                const hasTrump = state.myHand.some(c => c.isTrump);
                return !hasTrump;
            }

            // Si on demande une couleur
            if (card.suit === leadSuit) return true;
            
            // Si on n'a pas la couleur demand√©e
            const hasSuit = state.myHand.some(c => c.suit === leadSuit);
            if (hasSuit) return false;

            // On doit couper avec un atout
            if (card.isTrump) {
                // Si quelqu'un a d√©j√† coup√©, on doit surcouper si possible
                let highestTrump = 0;
                let someoneAlreadyCut = false;
                
                state.gameState.trickCards.forEach(tc => {
                    if (tc.card.isTrump && !tc.card.isExcuse) {
                        someoneAlreadyCut = true;
                        const trumpValue = parseInt(tc.card.value);
                        if (trumpValue > highestTrump) {
                            highestTrump = trumpValue;
                        }
                    }
                });
                
                if (someoneAlreadyCut) {
                    const myTrumpValue = parseInt(card.value);
                    
                    // Je dois surcouper si j'ai un atout plus haut
                    if (myTrumpValue > highestTrump) {
                        return true;
                    } else {
                        const hasHigherTrump = state.myHand.some(c => 
                            c.isTrump && !c.isExcuse && parseInt(c.value) > highestTrump
                        );
                        return !hasHigherTrump;
                    }
                }
                
                return true; // Premi√®re coupe, n'importe quel atout
            }
            
            // On peut d√©fausser si on n'a pas d'atout
            const hasTrump = state.myHand.some(c => c.isTrump);
            return !hasTrump;
        }

        function showScores(scores, detail) {
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('scoresScreen').style.display = 'block';

            const tbody = document.getElementById('scoresBody');
            tbody.innerHTML = '';

            const contractLabels = {
                'petite': 'Petite',
                'garde': 'Garde',
                'garde-sans': 'Garde sans',
                'garde-contre': 'Garde contre'
            };

            // D√©tail du calcul
            if (detail) {
                const detailRow = document.createElement('tr');
                detailRow.style.background = '#e3f2fd';
                const detailCell = document.createElement('td');
                detailCell.colSpan = 2;
                detailCell.style.cssText = 'padding: 15px;';

                const contractLabel = contractLabels[detail.contract] || detail.contract;
                const success = detail.difference >= 0;
                const successIcon = success ? '‚úÖ' : '‚ùå';
                const petitLine = detail.petitBonus !== 0
                    ? `<tr><td>Petit au bout</td><td style="text-align:right;">${detail.petitBonus > 0 ? '+' : ''}${detail.petitBonus}</td></tr>`
                    : '';

                const absDiff = Math.abs(detail.difference).toFixed(1);
                const signedTotal = success ? detail.baseScore * detail.multiplier : -(detail.baseScore * detail.multiplier);
                const petitPart = detail.petitBonus !== 0 ? ` ${detail.petitBonus > 0 ? '+' : '-'} ${Math.abs(detail.petitBonus)}` : '';
                const formulaSign = success ? '' : '-';
                const scoreColor = success ? '#27ae60' : '#e74c3c';

                detailCell.innerHTML = `
                    <table style="width:100%; border-collapse:collapse; font-size:0.95em;">
                        <tr style="border-bottom:1px solid #90caf9;">
                            <td style="padding:4px 0;"><strong>Annonce</strong></td>
                            <td style="text-align:right; padding:4px 0;"><strong>${contractLabel} (x${detail.multiplier})</strong></td>
                        </tr>
                        <tr>
                            <td style="padding:4px 0;">Points du preneur</td>
                            <td style="text-align:right;">${detail.takerScore.toFixed(1)}</td>
                        </tr>
                        <tr>
                            <td>Points de la d√©fense</td>
                            <td style="text-align:right;">${detail.defenseScore.toFixed(1)}</td>
                        </tr>
                        <tr style="border-bottom:1px solid #90caf9;">
                            <td>Bouts du preneur</td>
                            <td style="text-align:right;">${detail.takerBouts} bout${detail.takerBouts > 1 ? 's' : ''} ‚Üí contrat de ${detail.requiredPoints} pts</td>
                        </tr>
                        <tr>
                            <td>Diff√©rence</td>
                            <td style="text-align:right; color: ${detail.difference >= 0 ? '#27ae60' : '#e74c3c'};">${detail.difference >= 0 ? '+' : ''}${detail.difference.toFixed(1)} pts ${successIcon}</td>
                        </tr>
                        <tr>
                            <td>${success ? 'Bonus contrat' : 'Malus contrat'}</td>
                            <td style="text-align:right; color: ${scoreColor};">${success ? '+' : '-'}25</td>
                        </tr>
                        ${petitLine}
                        <tr style="border-top:1px solid #90caf9; font-weight:bold;">
                            <td style="padding:6px 0;">Score du preneur</td>
                            <td style="text-align:right; color: ${scoreColor};">${formulaSign}(${absDiff} + 25${petitPart}) x ${detail.multiplier} = ${signedTotal > 0 ? '+' : ''}${signedTotal}</td>
                        </tr>
                    </table>
                `;
                detailRow.appendChild(detailCell);
                tbody.appendChild(detailRow);

                const sep = document.createElement('tr');
                sep.innerHTML = '<td colspan="2" style="height: 10px;"></td>';
                tbody.appendChild(sep);
            }

            // Trier par score d√©croissant
            scores.sort((a, b) => b.score - a.score);

            // S√©parer preneur/partenaire et d√©fense
            const takerTeam = scores.filter(s => s.isTaker || s.isPartner);
            const defenseTeam = scores.filter(s => !s.isTaker && !s.isPartner);

            const hasTakerTeam = takerTeam.length > 0;
            const hasPartner = takerTeam.length > 1;

            // Afficher l'√©quipe du preneur
            if (hasTakerTeam) {
                const headerRow = document.createElement('tr');
                headerRow.style.background = '#e8f5e9';
                headerRow.innerHTML = `
                    <td colspan="2" style="font-weight: bold; text-align: center; padding: 15px; color: #27ae60;">
                        ${hasPartner ? 'ü§ù √âquipe Preneur' : 'üë§ Preneur (seul)'}
                    </td>
                `;
                tbody.appendChild(headerRow);

                takerTeam.forEach((s, index) => {
                    const row = document.createElement('tr');
                    const badge = s.isTaker ? 'üëë Preneur' : 'ü§ù Partenaire';
                    row.innerHTML = `
                        <td style="padding-left: 30px;">${badge} - ${s.name}</td>
                        <td style="font-weight: bold; color: ${s.score >= 0 ? '#27ae60' : '#e74c3c'};">${s.score > 0 ? '+' : ''}${s.score} points</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            // Afficher l'√©quipe de d√©fense
            if (defenseTeam.length > 0) {
                const headerRow = document.createElement('tr');
                headerRow.style.background = '#ffebee';
                headerRow.innerHTML = `
                    <td colspan="2" style="font-weight: bold; text-align: center; padding: 15px; color: #c62828;">
                        üõ°Ô∏è D√©fense (${defenseTeam.length} joueur${defenseTeam.length > 1 ? 's' : ''})
                    </td>
                `;
                tbody.appendChild(headerRow);

                defenseTeam.forEach((s, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="padding-left: 30px;">${s.name}</td>
                        <td style="font-weight: bold; color: ${s.score >= 0 ? '#27ae60' : '#e74c3c'};">${s.score > 0 ? '+' : ''}${s.score} points</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            // Ligne de s√©paration
            const separatorRow = document.createElement('tr');
            separatorRow.innerHTML = '<td colspan="2" style="height: 20px;"></td>';
            tbody.appendChild(separatorRow);

            // Afficher le chien pour garde-sans et garde-contre (r√©v√©l√© en fin de partie)
            const contract = state.gameState && state.gameState.contract;
            if ((contract === 'garde-sans' || contract === 'garde-contre') && state.dogCards && state.dogCards.length > 0) {
                const dogRow = document.createElement('tr');
                dogRow.style.background = '#fff3e0';
                const dogCell = document.createElement('td');
                dogCell.colSpan = 2;
                dogCell.style.cssText = 'text-align: center; padding: 15px;';
                dogCell.innerHTML = '<strong>üé¥ Le Chien :</strong><div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 10px;"></div>';
                const dogContainer = dogCell.querySelector('div');
                state.dogCards.forEach(card => {
                    const cardDiv = createCardElement(card, false);
                    cardDiv.style.width = '50px';
                    cardDiv.style.height = '75px';
                    cardDiv.style.cursor = 'default';
                    dogContainer.appendChild(cardDiv);
                });
                dogRow.appendChild(dogCell);
                tbody.appendChild(dogRow);
            }

            // Afficher le r√©sultat du contrat
            const takerTotalScore = takerTeam.reduce((sum, s) => sum + s.score, 0);
            const resultRow = document.createElement('tr');
            resultRow.style.background = takerTotalScore > 0 ? '#c8e6c9' : '#ffcdd2';
            resultRow.style.fontSize = '1.1em';
            resultRow.innerHTML = `
                <td colspan="2" style="text-align: center; padding: 15px; font-weight: bold;">
                    ${takerTotalScore > 0 ? '‚úÖ Contrat r√©ussi !' : '‚ùå Contrat chut√©'}
                </td>
            `;
            tbody.appendChild(resultRow);
        }

        // ========== FONCTIONS POUR LES ENCH√àRES ==========

        function showBiddingScreen() {
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('biddingScreen').style.display = 'block';
            
            // Rendre la main du joueur
            renderBiddingHand();
        }

        function renderBiddingHand() {
            const container = document.getElementById('biddingPlayerHand');
            container.innerHTML = '';
            document.getElementById('biddingHandCount').textContent = state.myHand.length;

            state.myHand.forEach((card, index) => {
                const cardDiv = createCardElement(card, true);
                cardDiv.onclick = null; // Pas cliquable pendant les ench√®res
                cardDiv.style.cursor = 'default';
                container.appendChild(cardDiv);
            });
        }

        function updateBiddingInfo(currentPlayerIndex, isMyTurn) {
            const currentPlayer = state.players[currentPlayerIndex];
            const turnInfo = document.getElementById('biddingTurnInfo');
            
            if (isMyTurn) {
                turnInfo.textContent = 'üéØ √Ä vous d\'ench√©rir !';
                turnInfo.style.color = '#27ae60';
                document.getElementById('biddingButtons').style.display = 'block';
            } else {
                turnInfo.textContent = `‚è≥ ${currentPlayer.name} est en train d'ench√©rir...`;
                turnInfo.style.color = '#666';
                document.getElementById('biddingButtons').style.display = 'none';
            }

            // Afficher les ench√®res pr√©c√©dentes
            const bidsDiv = document.getElementById('currentBids');
            bidsDiv.innerHTML = '';
            if (state.currentBids.length > 0) {
                bidsDiv.innerHTML = '<strong>Ench√®res :</strong><br>' + 
                    state.currentBids.map(b => `${state.players[b.playerIndex].name}: ${formatBid(b.bid)}`).join(' ‚Ä¢ ');
            }

            // D√©sactiver les ench√®res inf√©rieures √† la meilleure ench√®re actuelle
            updateBidButtons();
        }

        function formatBid(bid) {
            const labels = {
                'pass': 'Passe',
                'petite': 'Petite',
                'garde': 'Garde',
                'garde-sans': 'Garde sans',
                'garde-contre': 'Garde contre'
            };
            return labels[bid] || bid;
        }

        function updateBidButtons() {
            const bidValues = { 'pass': 0, 'petite': 1, 'garde': 2, 'garde-sans': 3, 'garde-contre': 4 };
            let highestBidValue = 0;

            state.currentBids.forEach(b => {
                if (b.bid !== 'pass' && bidValues[b.bid] > highestBidValue) {
                    highestBidValue = bidValues[b.bid];
                }
            });

            // D√©sactiver les boutons d'ench√®res qui ne sont pas sup√©rieurs √† la meilleure ench√®re
            ['petite', 'garde', 'garde-sans', 'garde-contre'].forEach(bid => {
                const btn = document.getElementById('bid' + bid.charAt(0).toUpperCase() + bid.slice(1).replace('-', ''));
                if (btn) {
                    // On ne peut ench√©rir que si c'est STRICTEMENT sup√©rieur
                    if (bidValues[bid] <= highestBidValue) {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        btn.style.cursor = 'not-allowed';
                    } else {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    }
                }
            });
        }

        function makeBid(bid) {
            socket.emit('makeBid', {
                roomCode: state.roomCode,
                bid: bid
            });

            document.getElementById('biddingButtons').style.display = 'none';
        }

        // ========== FONCTIONS POUR LE CHIEN ET L'√âCART ==========

        function showDogScreen(dogCards) {
            document.getElementById('biddingScreen').style.display = 'none';
            
            // Garder le chien visible pour tous - ne pas le masquer
            // Le chien est d√©j√† affich√© dans dogDisplay depuis biddingComplete
            
            document.getElementById('dogScreen').style.display = 'block';

            state.dogCards = dogCards;
            state.selectedDogCards = [];

            // Ajouter les cartes du chien √† la main
            state.myHand = state.myHand.concat(dogCards);
            sortHand(state.myHand);

            // Afficher le nombre de cartes √† √©carter
            const dogSize = dogCards.length;
            document.getElementById('dogCardsNeeded').textContent = dogSize;
            document.getElementById('selectedNeeded').textContent = dogSize;

            renderDogCards();
            renderDogHand();
        }

        function sortHand(hand) {
            hand.sort((a, b) => {
                // L'Excuse va avec les atouts
                const aIsTrumpOrExcuse = a.isTrump || a.isExcuse;
                const bIsTrumpOrExcuse = b.isTrump || b.isExcuse;
                
                // Les atouts (+ Excuse) √† la fin
                if (aIsTrumpOrExcuse && !bIsTrumpOrExcuse) return 1;
                if (!aIsTrumpOrExcuse && bIsTrumpOrExcuse) return -1;
                
                // Parmi les atouts/excuse
                if (aIsTrumpOrExcuse && bIsTrumpOrExcuse) {
                    // L'Excuse en premier (valeur 0)
                    if (a.isExcuse) return -1;
                    if (b.isExcuse) return 1;
                    // Puis les atouts par ordre croissant
                    return parseInt(a.value) - parseInt(b.value);
                }
                
                // Pour les couleurs : ordre Pique, C≈ìur, Tr√®fle, Carreau
                const suitOrder = { '‚ô†': 0, '‚ô•': 1, '‚ô£': 2, '‚ô¶': 3 };
                if (suitOrder[a.suit] !== suitOrder[b.suit]) {
                    return suitOrder[a.suit] - suitOrder[b.suit];
                }
                
                // M√™me couleur : trier par valeur
                const aVal = isNaN(a.value) ? ({ 'V': 11, 'C': 12, 'D': 13, 'R': 14 }[a.value] || 0) : parseInt(a.value);
                const bVal = isNaN(b.value) ? ({ 'V': 11, 'C': 12, 'D': 13, 'R': 14 }[b.value] || 0) : parseInt(b.value);
                
                return aVal - bVal;
            });
        }

        function renderDogCards() {
            const container = document.getElementById('dogCards');
            container.innerHTML = '';

            state.dogCards.forEach(card => {
                const cardDiv = createCardElement(card, false);
                cardDiv.style.width = '60px';
                cardDiv.style.height = '90px';
                container.appendChild(cardDiv);
            });
        }

        function renderDogHand() {
            const container = document.getElementById('dogPlayerHand');
            container.innerHTML = '';
            document.getElementById('dogHandCount').textContent = state.myHand.length;

            state.myHand.forEach((card, index) => {
                const cardDiv = createCardElement(card, true);
                
                // V√©rifier si la carte est s√©lectionn√©e
                const isSelected = state.selectedDogCards.some(c => 
                    c.suit === card.suit && c.value === card.value
                );
                
                if (isSelected) {
                    cardDiv.classList.add('selected');
                }

                cardDiv.onclick = () => toggleDogCard(card, index);
                container.appendChild(cardDiv);
            });

            updateDogSelection();
        }

        function createCardElement(card, fullSize = true) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            if (!fullSize) {
                cardDiv.style.fontSize = '0.8em';
            }
            
            if (card.isTrump) {
                cardDiv.classList.add('trump');
                cardDiv.innerHTML = `
                    <div class="card-center">
                        <div class="trump-number">${card.value}</div>
                        <div class="trump-label">Atout</div>
                    </div>
                `;
            } else if (card.isExcuse) {
                cardDiv.innerHTML = `
                    <div class="card-center">
                        <div class="excuse-star">‚òÖ</div>
                        <div class="excuse-label">L'Excuse</div>
                    </div>
                `;
            } else {
                const suitClass = card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'hearts' : 'clubs';
                cardDiv.classList.add(suitClass);
                
                // Labels pour les figures
                const figureLabels = {
                    'V': 'Valet',
                    'C': 'Cavalier', 
                    'D': 'Dame',
                    'R': 'Roi'
                };
                
                const isFigure = ['V', 'C', 'D', 'R'].includes(card.value);
                
                if (isFigure) {
                    cardDiv.innerHTML = `
                        <div class="card-corner top-left">
                            <div>${card.value}</div>
                            <div>${card.suit}</div>
                        </div>
                        <div class="card-center">
                            <div class="card-figure">${figureLabels[card.value]}</div>
                            <div class="card-suit" style="font-size: 2em; margin-top: 5px;">${card.suit}</div>
                        </div>
                        <div class="card-corner bottom-right">
                            <div>${card.value}</div>
                            <div>${card.suit}</div>
                        </div>
                    `;
                } else {
                    cardDiv.innerHTML = `
                        <div class="card-corner top-left">
                            <div>${card.value}</div>
                            <div>${card.suit}</div>
                        </div>
                        <div class="card-center">
                            <div class="card-suit" style="font-size: 2.5em;">${card.suit}</div>
                        </div>
                        <div class="card-corner bottom-right">
                            <div>${card.value}</div>
                            <div>${card.suit}</div>
                        </div>
                    `;
                }
            }

            return cardDiv;
        }

        function toggleDogCard(card, index) {
            const expectedCount = state.dogCards.length; // 3 ou 6
            
            const isSelected = state.selectedDogCards.some(c => 
                c.suit === card.suit && c.value === card.value
            );

            if (isSelected) {
                // D√©s√©lectionner
                state.selectedDogCards = state.selectedDogCards.filter(c => 
                    !(c.suit === card.suit && c.value === card.value)
                );
            } else {
                // V√©rifier si on peut s√©lectionner cette carte
                if (state.selectedDogCards.length >= expectedCount) {
                    showMessage(`‚ùå Vous ne pouvez s√©lectionner que ${expectedCount} cartes`);
                    return;
                }

                // V√©rifier les r√®gles de l'√©cart
                if (card.value === 'R') {
                    showMessage('‚ùå Vous ne pouvez pas √©carter un Roi');
                    return;
                }

                if (card.isTrump) {
                    // On peut √©carter un atout seulement si on a l'Excuse et qu'on l'√©carte aussi
                    const hasExcuse = state.myHand.some(c => c.isExcuse);
                    const excuseSelected = state.selectedDogCards.some(c => c.isExcuse);
                    
                    if (!hasExcuse || !excuseSelected) {
                        showMessage('‚ùå Vous ne pouvez √©carter un atout que si vous √©cartez aussi l\'Excuse');
                        return;
                    }
                }

                state.selectedDogCards.push(card);
            }

            renderDogHand();
        }

        function updateDogSelection() {
            const expectedCount = state.dogCards.length; // 3 ou 6
            document.getElementById('selectedCount').textContent = state.selectedDogCards.length;
            
            const selectedContainer = document.getElementById('selectedCards');
            selectedContainer.innerHTML = '';
            
            state.selectedDogCards.forEach(card => {
                const cardDiv = createCardElement(card, false);
                cardDiv.style.width = '50px';
                cardDiv.style.height = '75px';
                selectedContainer.appendChild(cardDiv);
            });

            const validateBtn = document.getElementById('validateDogBtn');
            if (state.selectedDogCards.length === expectedCount) {
                validateBtn.disabled = false;
                validateBtn.style.opacity = '1';
            } else {
                validateBtn.disabled = true;
                validateBtn.style.opacity = '0.5';
            }
        }

        function validateDog() {
            const expectedCount = state.dogCards.length; // 3 ou 6 selon le nombre de joueurs
            
            if (state.selectedDogCards.length !== expectedCount) {
                showMessage(`‚ùå Vous devez s√©lectionner exactement ${expectedCount} cartes`);
                return;
            }

            socket.emit('setDog', {
                roomCode: state.roomCode,
                dogCards: state.selectedDogCards
            });

            // Le serveur va retirer les cartes - on ne modifie pas state.myHand ici
            state.selectedDogCards = [];
        }

        // ========== FONCTIONS POUR L'APPEL DE ROI ==========

        function showKingCallScreen() {
            document.getElementById('biddingScreen').style.display = 'none';
            document.getElementById('dogScreen').style.display = 'none';
            document.getElementById('kingCallScreen').style.display = 'block';
            
            // Afficher la main du preneur
            renderKingCallHand();
        }

        function renderKingCallHand() {
            const container = document.getElementById('kingCallPlayerHand');
            container.innerHTML = '';
            document.getElementById('kingCallHandCount').textContent = state.myHand.length;

            state.myHand.forEach((card, index) => {
                const cardDiv = createCardElement(card, true);
                cardDiv.onclick = null; // Pas cliquable pendant l'appel
                cardDiv.style.cursor = 'default';
                container.appendChild(cardDiv);
            });
        }

        function callKing(suit) {
            socket.emit('callKing', {
                roomCode: state.roomCode,
                suit: suit
            });

            document.getElementById('kingCallButtons').style.display = 'none';
            document.getElementById('kingCallMessage').innerHTML = '<p style="color: #27ae60; font-weight: bold;">‚è≥ En attente du d√©but de la partie...</p>';
        }

        // ========== GESTION DES √âV√âNEMENTS SOCKET.IO (MISE √Ä JOUR) ==========

        // Partie cr√©√©e
        socket.on('roomCreated', ({ roomCode, playerId, players, maxPlayers }) => {
            state.roomCode = roomCode;
            state.playerId = playerId;
            state.players = players;
            state.playerCount = maxPlayers;
            showLobby();
        });

        // Partie rejointe
        socket.on('roomJoined', ({ roomCode, playerId, players, maxPlayers }) => {
            state.roomCode = roomCode;
            state.playerId = playerId;
            state.players = players;
            state.playerCount = maxPlayers;
            showLobby();
        });

        // Un joueur a rejoint
        socket.on('playerJoined', ({ players }) => {
            state.players = players;
            updatePlayersList();
            if (state.isHost) {
                checkStartGameButton();
            }
        });

        // Un joueur a quitt√©
        socket.on('playerLeft', ({ players }) => {
            state.players = players;
            updatePlayersList();
            if (state.isHost) {
                checkStartGameButton();
            }
        });

        // La partie a d√©marr√©
        socket.on('gameStarted', ({ hand, gameState, players }) => {
            state.myHand = hand;
            state.gameState = {
                ...gameState,
                trickCards: []
            };
            state.players = players;
            state.currentTrick = gameState.currentTrick;
            state.playedCards = [];
            state.currentBids = [];
            
            showMessage('üé¥ La partie commence !');
        });

        // Phase d'ench√®res
        socket.on('biddingPhase', ({ currentPlayerIndex }) => {
            if (!state.gameState) {
                state.gameState = { currentPlayerIndex };
            } else {
                state.gameState.currentPlayerIndex = currentPlayerIndex;
            }
            
            showBiddingScreen();
            
            const playerIndex = state.players.findIndex(p => p.id === state.playerId);
            const isMyTurn = currentPlayerIndex === playerIndex;
            
            updateBiddingInfo(currentPlayerIndex, isMyTurn);
        });

        // Une ench√®re a √©t√© faite
        socket.on('bidMade', ({ playerIndex, bid, nextPlayerIndex }) => {
            state.currentBids.push({ playerIndex, bid });
            
            const player = state.players[playerIndex];
            showMessage(`${player.name} : ${formatBid(bid)}`);
            
            const myPlayerIndex = state.players.findIndex(p => p.id === state.playerId);
            const isMyTurn = nextPlayerIndex === myPlayerIndex;
            
            updateBiddingInfo(nextPlayerIndex, isMyTurn);
        });

        // Ench√®res termin√©es
        socket.on('biddingComplete', ({ takerIndex, takerName, contract, dogCards }) => {
            state.gameState.takerIndex = takerIndex;
            state.gameState.taker = takerName;
            state.gameState.contract = contract;
            state.gameState.phase = 'playing';
            state.gameState.trickCards = [];
            
            // Cacher l'√©cran d'ench√®res
            document.getElementById('biddingScreen').style.display = 'none';
            
            // Sauvegarder le chien
            if (dogCards) {
                state.dogCards = dogCards;
                // Afficher le chien seulement pour petite et garde (pas garde-sans ni garde-contre)
                if (contract === 'petite' || contract === 'garde') {
                    displayDogForAll(dogCards);
                }
            }
            
            showMessage(`üéØ ${takerName} prend avec ${formatBid(contract)} !`);
            
            // Ne pas passer directement au jeu, attendre les √©v√©nements serveur
        });

        function displayDogForAll(dogCards) {
            const dogDisplay = document.getElementById('dogDisplay');
            const dogCardsDisplay = document.getElementById('dogCardsDisplay');
            
            dogCardsDisplay.innerHTML = '';
            
            dogCards.forEach(card => {
                const cardDiv = createCardElement(card, false);
                cardDiv.style.width = '35px';
                cardDiv.style.height = '52px';
                cardDiv.style.fontSize = '0.5em';
                cardDiv.onclick = null;
                cardDiv.style.cursor = 'default';
                dogCardsDisplay.appendChild(cardDiv);
            });
            
            // Afficher le chien
            dogDisplay.classList.remove('hidden');
        }

        // Recevoir le chien
        socket.on('receiveDog', ({ dogCards }) => {
            showMessage('üé¥ Vous avez re√ßu le chien !');
            setTimeout(() => {
                showDogScreen(dogCards);
            }, 1500);
        });

        // Message pour les autres joueurs pendant l'√©cart
        socket.on('waitingForDog', ({ }) => {
            showMessage('‚è≥ Le preneur fait son √©cart...');
            showWaitingDogScreen();
        });

        // L'√©cart a √©t√© valid√©
        socket.on('dogSet', ({ updatedHand }) => {
            showMessage('‚úÖ √âcart valid√© !');
            
            // Mettre √† jour la main avec celle du serveur
            if (updatedHand) {
                state.myHand = updatedHand;
                sortHand(state.myHand);
                
                // Forcer le rafra√Æchissement visuel si on est d√©j√† dans l'√©cran de jeu
                if (document.getElementById('gameScreen').style.display === 'block') {
                    renderPlayerHand();
                }
            }
            
            document.getElementById('dogScreen').style.display = 'none';
        });

        // Demande d'appel de Roi
        socket.on('requestKingCall', ({ isTaker }) => {
            if (isTaker) {
                showMessage('üëë Appelez un Roi pour jouer avec vous');
                setTimeout(() => {
                    showKingCallScreen();
                    document.getElementById('kingCallButtons').style.display = 'block';
                }, 1500);
            } else {
                showMessage('üëë Le preneur est en train d\'appeler un Roi...');
                setTimeout(() => {
                    showKingCallScreen();
                    document.getElementById('kingCallButtons').style.display = 'none';
                    document.getElementById('kingCallMessage').innerHTML = '<p>‚è≥ Le preneur est en train d\'appeler un Roi...</p>';
                }, 1500);
            }
        });

        // Un Roi a √©t√© appel√©
        socket.on('kingCalled', ({ suit, calledKing }) => {
            showMessage(`üëë Le ${calledKing} a √©t√© appel√© !`);
            if (state.gameState) {
                state.gameState.calledKing = calledKing;
                state.gameState.calledKingSuit = suit;
            }
            
            // Afficher le Roi appel√© dans le header
            document.getElementById('calledKingInfo').style.display = 'block';
            document.getElementById('calledKingValue').textContent = calledKing;
        });

        // D√©but de la phase de jeu
        socket.on('startPlaying', ({ hand }) => {
            showMessage('üéÆ C\'est parti !');
            state.currentTrick = 1; // Initialiser le premier pli
            
            // Mettre √† jour la main si fournie
            if (hand) {
                state.myHand = hand;
                sortHand(state.myHand);
            }
            
            setTimeout(() => {
                showGameScreen();
            }, 1500);
        });

        // Une carte a √©t√© jou√©e
        socket.on('cardPlayed', ({ playerIndex, card, trickCards, remainingCards }) => {
            const player = state.players[playerIndex];
            
            // Si c'est le joueur actuel qui a jou√©
            if (player.id === state.playerId) {
                // Retirer la carte de la main
                const cardIndex = state.myHand.findIndex(c => 
                    c.suit === card.suit && c.value === card.value
                );
                if (cardIndex !== -1) {
                    state.myHand.splice(cardIndex, 1);
                }
                renderPlayerHand();
            } else {
                // Mettre √† jour le nombre de cartes de l'adversaire
                player.cardCount = remainingCards;
                renderOpponents();
            }
            
            state.playedCards = trickCards;
            renderPlayedCards();
        });

        // Passer au joueur suivant
        socket.on('nextPlayer', ({ currentPlayerIndex }) => {
            state.gameState.currentPlayerIndex = currentPlayerIndex;
            renderOpponents();
            
            const currentPlayer = state.players[currentPlayerIndex];
            if (currentPlayer.id === state.playerId) {
                showMessage('üéØ √Ä vous de jouer !');
            }
        });

        // Pli termin√©
        socket.on('trickComplete', ({ winnerIndex, winnerName, trickPoints, takerScore, defenseScore }) => {
            state.gameState.takerScore = takerScore;
            state.gameState.defenseScore = defenseScore;
            
            const winnerDiv = document.getElementById('trickWinner');
            winnerDiv.innerHTML = `
                <div style="font-size: 1.1em; margin-bottom: 10px;">
                    <strong>${winnerName}</strong> remporte le pli ! 
                    <span style="color: #f39c12;">(+${trickPoints.toFixed(1)} pts)</span>
                </div>
                <div style="font-size: 0.9em; opacity: 0.9;">
                    üéØ Preneur: ${takerScore.toFixed(1)} pts | üõ°Ô∏è D√©fense: ${defenseScore.toFixed(1)} pts
                </div>
            `;
            winnerDiv.classList.remove('hidden');
            
            updateGameHeader();
        });

        // Nouveau pli
        socket.on('newTrick', ({ currentPlayerIndex, currentTrick, lastTrickCards }) => {
            const winnerDiv = document.getElementById('trickWinner');
            winnerDiv.classList.add('hidden');
            
            // Sauvegarder et afficher le dernier pli
            if (lastTrickCards && lastTrickCards.length > 0) {
                displayLastTrick(lastTrickCards);
            }
            
            // Masquer le chien √† partir du 2√®me pli
            if (currentTrick >= 2) {
                const dogDisplay = document.getElementById('dogDisplay');
                if (dogDisplay) {
                    dogDisplay.classList.add('hidden');
                }
                // Afficher le bouton debug pour sauter au dernier pli
                document.getElementById('debugSkipBtn').style.display = 'inline-block';
            }
            
            state.playedCards = [];
            state.gameState.trickCards = [];
            state.gameState.leadSuit = null;
            state.gameState.currentPlayerIndex = currentPlayerIndex;
            state.currentTrick = currentTrick;
            
            renderPlayedCards();
            updateGameHeader();
            renderOpponents();
        });

        // Partie termin√©e
        socket.on('gameFinished', ({ scores, takerScore, defenseScore, contract, takerName, requiredPoints, takerBouts, multiplier, petitBonus, baseScore, difference }) => {
            showMessage(`üéâ Partie termin√©e ! ${takerName} a fait ${takerScore.toFixed(1)} points`);

            setTimeout(() => {
                showScores(scores, {
                    takerScore, defenseScore, contract, takerName,
                    requiredPoints, takerBouts, multiplier, petitBonus,
                    baseScore, difference
                });
            }, 3000);
        });

        // Retour au lobby pour une nouvelle partie
        socket.on('returnToLobby', ({ players }) => {
            state.players = players;
            state.gameState = null;
            state.myHand = [];
            state.playedCards = [];
            state.currentTrick = 0;
            state.selectedDogCards = [];
            state.dogCards = [];
            state.currentBids = [];
            state.lastTrickCards = null;
            
            document.getElementById('scoresScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            
            updatePlayersList();
            showMessage('üéÆ Pr√™t pour une nouvelle partie !');
        });

        // Tous les joueurs ont pass√© ‚Üí redistribution automatique
        socket.on('allPassed', () => {
            state.currentBids = [];
            showMessage('‚ùå Tous les joueurs ont pass√©. Nouvelle donne...');
        });

        // Erreur
        socket.on('error', ({ message }) => {
            showMessage('‚ùå ' + message);
        });

        function playCard(index) {
            const card = state.myHand[index];
            
            if (!canPlayCard(card)) {
                showMessage('‚ùå Vous ne pouvez pas jouer cette carte');
                return;
            }

            // Envoyer la carte (pas l'index) pour √©viter les probl√®mes de d√©synchronisation
            socket.emit('playCard', {
                roomCode: state.roomCode,
                card: {
                    suit: card.suit,
                    value: card.value,
                    isTrump: card.isTrump,
                    isExcuse: card.isExcuse
                }
            });
        }

        function renderPlayedCards() {
            if (!state.playedCards) return;
            
            const center = document.getElementById('centerArea');
            center.innerHTML = '';

            state.playedCards.forEach(({card}) => {
                const cardDiv = createCardElement(card, true);
                cardDiv.style.width = '80px';
                cardDiv.style.height = '120px';
                center.appendChild(cardDiv);
            });
        }

        function displayLastTrick(trickCards) {
            if (!trickCards || trickCards.length === 0) return;
            
            state.lastTrickCards = trickCards;
            
            const lastTrickDisplay = document.getElementById('lastTrickDisplay');
            const lastTrickCardsContainer = document.getElementById('lastTrickCards');
            
            lastTrickCardsContainer.innerHTML = '';
            
            trickCards.forEach(({card}) => {
                const cardDiv = createCardElement(card, false);
                cardDiv.style.width = '40px';
                cardDiv.style.height = '60px';
                cardDiv.style.fontSize = '0.6em';
                cardDiv.onclick = null;
                cardDiv.style.cursor = 'default';
                lastTrickCardsContainer.appendChild(cardDiv);
            });
            
            lastTrickDisplay.classList.remove('hidden');
        }



        function skipToLastTrick() {
            document.getElementById('debugSkipBtn').style.display = 'none';
            socket.emit('skipToLastTrick', { roomCode: state.roomCode });
        }

        socket.on('skipToLastTrickDone', ({ hand, currentPlayerIndex, currentTrick, takerScore, defenseScore }) => {
            state.myHand = hand;
            state.playedCards = [];
            state.gameState.trickCards = [];
            state.gameState.leadSuit = null;
            state.gameState.currentPlayerIndex = currentPlayerIndex;
            state.currentTrick = currentTrick;

            document.getElementById('debugSkipBtn').style.display = 'none';
            document.getElementById('lastTrickDisplay').classList.add('hidden');

            renderPlayerHand();
            renderPlayedCards();
            renderOpponents();
            updateGameHeader();
            showMessage(`‚è© Saut√© au pli ${currentTrick} | Preneur: ${takerScore.toFixed(1)} pts | D√©fense: ${defenseScore.toFixed(1)} pts`);
        });

        function leaveGame() {
            if (confirm('Voulez-vous vraiment quitter la partie ?')) {
                backToWelcome();
            }
        }

        function backToWelcome() {
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('biddingScreen').style.display = 'none';
            document.getElementById('dogScreen').style.display = 'none';
            document.getElementById('waitingDogScreen').style.display = 'none';
            document.getElementById('kingCallScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('scoresScreen').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'block';
            
            state.roomCode = '';
            state.playerId = null;
            state.isHost = false;
            state.players = [];
            state.gameState = null;
            state.myHand = [];
        }

        function startNewGame() {
            socket.emit('restartGame', { roomCode: state.roomCode });
            
            // Retour √† la salle d'attente
            document.getElementById('scoresScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            
            showMessage('üîÑ Nouvelle partie lanc√©e !');
        }

        // Gestion du lien partag√©
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');

            if (roomCode) {
                document.getElementById('roomCode').value = roomCode;
                document.querySelector('.player-count-selector').style.display = 'none';
                document.getElementById('roomButtons').style.display = 'none';
                showJoinRoom();
            }
        });
    </script>
</body>
</html>
